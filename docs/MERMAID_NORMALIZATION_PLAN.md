# Mermaid 代码正规化 (Normalization) 设计方案

## 1. 背景与目标

用户从外部来源（如 GitHub Issue、文档）复制的 Mermaid 代码可能存在语法不严谨的情况，最典型的问题是**节点或连线标签中包含特殊字符（如 `()`, `[]`, `?`, `:`）但未被双引号包裹**。这会导致 Mermaid 解析器报错。

本方案旨在后端提取代码后，增加一个 **"正规化 (Normalization)"** 步骤，自动检测并修复这些潜在的语法问题。

## 2. 技术方案 A：基于上下文感知的正则替换 (推荐)

我们将使用 **Go 语言的正则表达式** 对提取到的 Mermaid 代码进行逐行扫描。为了解决简单的正则容易误伤（如误匹配 `A[Text(inner)]` 中的 `(inner)`）的问题，我们采用 **上下文感知 (Context-Aware)** 和 **分而治之** 的策略。

### 2.1 核心策略

1.  **针对性匹配**: 不使用统一大正则，而是为每种形状（`[]`, `()`, `{}` 等）单独定义规则。
2.  **严格的前缀断言**: 利用正则的非捕获组，严格限定“节点ID”的前面必须是合法的语法边界（行首、空格、箭头等），从而**杜绝误匹配节点内部文本**。
3.  **优先级控制**: 优先处理长符号（如 `{{`），后处理短符号（如 `{`）。

### 2.2 形状配置与正则构造

我们需要定义一个形状配置表。

**前缀允许字符集**: 行首 (`^`), 空白 (`\s`), 连接符 (`&`), 箭头字符 (`-`, `=`, `.`, `>`).

**通用正则模板**:
```regex
(?m)(?:^|\s|&|[-=.>])([A-Za-z0-9_-]+)\s*\[开符号\]([^"\[闭符号\]]+)\[闭符号\]
```
*(注：实际代码中需对符号进行转义)*

**处理顺序**:
1.  **Level 1 (双字符/特殊)**: `[[...]]`, `{{...}}`, `([ ... ])`, `[( ... )]`, `> ... ]`
2.  **Level 2 (单字符)**: `[...]`, `(...)`, `{...}`

### 2.3 伪代码示例

```go
type ShapeRule struct {
    Open  string
    Close string
    // 生成的正则将确保 ID 前面是合法字符
}

var shapes = []ShapeRule{
    {"[[", "]]"}, // Subroutine
    {"{{", "}}"}, // Hexagon
    {"([", "])"}, // Stadium
    {"[(", ")]"}, // DB
    {"[", "]"},   // Rect
    {"(", ")"},   // Round
    {"{", "}"},   // Rhombus
}

func NormalizeLine(line string) string {
    // 预编译正则应在 init 中完成
    for _, shape := range shapes {
        // 构造正则:
        // 前缀: (?:^|\s|&|[-=.>])
        // ID:   ([A-Za-z0-9_-]+)
        // 形状: Escaped(shape.Open)
        // 内容: ([^"]+)  <-- 简单起见，或者排除闭合符
        // 闭合: Escaped(shape.Close)
        
        // 执行 ReplaceAllStringFunc
        // 如果内容包含特殊字符 (?:, () [] 等)，则包裹引号
    }
    return line
}
```

## 3. 技术方案 B：词法解析器 (Parser) - 备选

### 3.1 方案描述
使用 Go 的解析器库（如 [participle](https://github.com/alecthomas/participle)）定义 Mermaid 的 EBNF 文法，将代码解析为 AST（抽象语法树），遍历 AST 修正节点 Value，再重新生成代码。

### 3.2 优缺点分析

*   **优点**:
    *   **终极准确**: 彻底解决嵌套、转义、多行等复杂语法问题，是编译器级别的解决方案。
    *   **结构化**: 可以理解代码逻辑，不仅仅是文本替换。

*   **缺点**:
    *   **文法复杂性**: Mermaid 语法非常宽松且包含多种图表类型（Flowchart, Sequence, Gantt, Class 等）。我们需要为所有图表类型编写完整的 EBNF 定义，否则解析器遇到不认识的语法（如 Sequence Diagram 的 `->>`）就会报错并拒绝处理。
    *   **过度设计**: 我们目前的需求仅仅是“给 Flowchart 的节点标签加引号”。引入一个通用的 Parser 库并维护庞大的文法定义，性价比（ROI）较低。
    *   **容错性差**: 正则方案遇到不懂的行会跳过（不破坏原意），而 Parser 遇到语法错误通常会直接失败，导致无法导入。

### 3.3 结论
考虑到 Mermaid 语法的多变性和我们要解决问题的单一性（仅针对 Flowchart 标签），**方案 A (正则)** 是目前性价比最高且足够稳健的选择。

## 4. 后续行动

1.  在 `desktop` 模块中实现 `NormalizeMermaid` 工具函数。
2.  按照方案 A 的优先级顺序编写单元测试（覆盖 `A[Text(inner)]` 等边缘情况）。
3.  集成到 `ImportFromClipboard` 流程中。
